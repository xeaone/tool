{
  "version": 3,
  "sources": ["../../post/mod.ts"],
  "sourcesContent": ["type Key = string | number | symbol;\ntype Data = BodyInit | Array<unknown> | Record<Key, unknown>;\ntype Result = Promise<string | Record<Key, unknown>>;\n\ntype BeforePost = <T extends Data>(data: T, url: URL) => Promise<void> | void;\ntype DuringPost = <T extends Data>(data: T, url: URL, code: number) => Promise<void> | void;\ntype AfterPost = <T extends Data>(data: T, url: URL, code: number) => Promise<void> | void;\n\ntype PostOptions = {\n    beforePost?: BeforePost;\n    duringPost?: DuringPost;\n    afterPost?: AfterPost;\n};\n\nexport default class Post {\n    beforePost?: BeforePost;\n    duringPost?: DuringPost;\n    afterPost?: AfterPost;\n\n    constructor(options: PostOptions) {\n        this.beforePost = options?.beforePost;\n        this.duringPost = options?.duringPost;\n        this.afterPost = options?.afterPost;\n    }\n\n    async method(path: string, data: Data): Result {\n        const url = new URL(path, globalThis.location.origin);\n\n        await this.beforePost?.(data, url);\n\n        try {\n            data = JSON.stringify(data);\n        } catch { /**/ }\n\n        const response = await globalThis.fetch(url.href, {\n            method: 'POST',\n            body: data as BodyInit,\n        });\n\n        if (!response.body) {\n            await this.afterPost?.(\n                data,\n                new URL(response.url),\n                response.status,\n            );\n            return {};\n        }\n\n        const decoder = new TextDecoder();\n        const reader = response.body.getReader();\n\n        let result = '';\n        let stream = await reader.read();\n\n        while (!stream.done) {\n            result += decoder.decode(stream.value, { stream: true });\n\n            await this.duringPost?.(\n                data,\n                new URL(response.url),\n                response.status,\n            );\n\n            stream = await reader.read();\n        }\n\n        try {\n            result = JSON.parse(result);\n        } catch { /**/ }\n\n        await this.afterPost?.(result, new URL(response.url), response.status);\n\n        return result;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;AAcA,IAAqB,OAArB,MAA0B;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,SAAsB;AAC9B,SAAK,aAAa,SAAS;AAC3B,SAAK,aAAa,SAAS;AAC3B,SAAK,YAAY,SAAS;AAAA,EAC9B;AAAA,EAEA,MAAM,OAAO,MAAc,MAAoB;AAC3C,UAAM,MAAM,IAAI,IAAI,MAAM,WAAW,SAAS,MAAM;AAEpD,UAAM,KAAK,aAAa,MAAM,GAAG;AAEjC,QAAI;AACA,aAAO,KAAK,UAAU,IAAI;AAAA,IAC9B,QAAQ;AAAA,IAAO;AAEf,UAAM,WAAW,MAAM,WAAW,MAAM,IAAI,MAAM;AAAA,MAC9C,QAAQ;AAAA,MACR,MAAM;AAAA,IACV,CAAC;AAED,QAAI,CAAC,SAAS,MAAM;AAChB,YAAM,KAAK;AAAA,QACP;AAAA,QACA,IAAI,IAAI,SAAS,GAAG;AAAA,QACpB,SAAS;AAAA,MACb;AACA,aAAO,CAAC;AAAA,IACZ;AAEA,UAAM,UAAU,IAAI,YAAY;AAChC,UAAM,SAAS,SAAS,KAAK,UAAU;AAEvC,QAAI,SAAS;AACb,QAAI,SAAS,MAAM,OAAO,KAAK;AAE/B,WAAO,CAAC,OAAO,MAAM;AACjB,gBAAU,QAAQ,OAAO,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAEvD,YAAM,KAAK;AAAA,QACP;AAAA,QACA,IAAI,IAAI,SAAS,GAAG;AAAA,QACpB,SAAS;AAAA,MACb;AAEA,eAAS,MAAM,OAAO,KAAK;AAAA,IAC/B;AAEA,QAAI;AACA,eAAS,KAAK,MAAM,MAAM;AAAA,IAC9B,QAAQ;AAAA,IAAO;AAEf,UAAM,KAAK,YAAY,QAAQ,IAAI,IAAI,SAAS,GAAG,GAAG,SAAS,MAAM;AAErE,WAAO;AAAA,EACX;AACJ;",
  "names": []
}
