{
  "version": 3,
  "sources": ["http-fetch:https://deno.land/std@0.204.0/encoding/_util.ts", "http-fetch:https://deno.land/std@0.204.0/encoding/base64.ts", "http-fetch:https://deno.land/std@0.204.0/encoding/base64url.ts", "../../jwt/mod.ts"],
  "sourcesContent": ["// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n\nconst encoder = new TextEncoder();\n\nfunction getTypeName(value: unknown): string {\n  const type = typeof value;\n  if (type !== \"object\") {\n    return type;\n  } else if (value === null) {\n    return \"null\";\n  } else {\n    return value?.constructor?.name ?? \"object\";\n  }\n}\n\nexport function validateBinaryLike(source: unknown): Uint8Array {\n  if (typeof source === \"string\") {\n    return encoder.encode(source);\n  } else if (source instanceof Uint8Array) {\n    return source;\n  } else if (source instanceof ArrayBuffer) {\n    return new Uint8Array(source);\n  }\n  throw new TypeError(\n    `The input must be a Uint8Array, a string, or an ArrayBuffer. Received a value of the type ${\n      getTypeName(source)\n    }.`,\n  );\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { validateBinaryLike } from \"./_util.ts\";\n\n/**\n * {@linkcode encodeBase64} and {@linkcode decodeBase64} for\n * [base64](https://en.wikipedia.org/wiki/Base64) encoding.\n *\n * This module is browser compatible.\n *\n * @example\n * ```ts\n * import {\n *   decodeBase64,\n *   encodeBase64,\n * } from \"https://deno.land/std@$STD_VERSION/encoding/base64.ts\";\n *\n * const b64Repr = \"Zm9vYg==\";\n *\n * const binaryData = decodeBase64(b64Repr);\n * console.log(binaryData);\n * // => Uint8Array [ 102, 111, 111, 98 ]\n *\n * console.log(encodeBase64(binaryData));\n * // => Zm9vYg==\n * ```\n *\n * @module\n */\n\nconst base64abc = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"+\",\n  \"/\",\n];\n\n/**\n * @deprecated (will be removed in 0.210.0) Use a `encodeBase64` instead.\n *\n * CREDIT: https://gist.github.com/enepomnyaschih/72c423f727d395eeaa09697058238727\n * Encodes a given Uint8Array, ArrayBuffer or string into RFC4648 base64 representation\n * @param data\n */\nexport const encode = encodeBase64;\n\n/**\n * @deprecated (will be removed in 0.210.0) Use a `decodeBase64` instead.\n *\n * Decodes a given RFC4648 base64 encoded string\n * @param b64\n */\nexport const decode = decodeBase64;\n\n/**\n * Encodes a given Uint8Array, ArrayBuffer or string into RFC4648 base64 representation\n */\nexport function encodeBase64(data: ArrayBuffer | Uint8Array | string): string {\n  // CREDIT: https://gist.github.com/enepomnyaschih/72c423f727d395eeaa09697058238727\n  const uint8 = validateBinaryLike(data);\n  let result = \"\",\n    i;\n  const l = uint8.length;\n  for (i = 2; i < l; i += 3) {\n    result += base64abc[uint8[i - 2] >> 2];\n    result += base64abc[((uint8[i - 2] & 0x03) << 4) | (uint8[i - 1] >> 4)];\n    result += base64abc[((uint8[i - 1] & 0x0f) << 2) | (uint8[i] >> 6)];\n    result += base64abc[uint8[i] & 0x3f];\n  }\n  if (i === l + 1) {\n    // 1 octet yet to write\n    result += base64abc[uint8[i - 2] >> 2];\n    result += base64abc[(uint8[i - 2] & 0x03) << 4];\n    result += \"==\";\n  }\n  if (i === l) {\n    // 2 octets yet to write\n    result += base64abc[uint8[i - 2] >> 2];\n    result += base64abc[((uint8[i - 2] & 0x03) << 4) | (uint8[i - 1] >> 4)];\n    result += base64abc[(uint8[i - 1] & 0x0f) << 2];\n    result += \"=\";\n  }\n  return result;\n}\n\n/**\n * Decodes a given RFC4648 base64 encoded string\n */\nexport function decodeBase64(b64: string): Uint8Array {\n  const binString = atob(b64);\n  const size = binString.length;\n  const bytes = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    bytes[i] = binString.charCodeAt(i);\n  }\n  return bytes;\n}\n", "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n/**\n * {@linkcode encodeBase64Url} and {@linkcode decodeBase64Url} for\n * [base64 URL safe](https://en.wikipedia.org/wiki/Base64#URL_applications) encoding.\n *\n * This module is browser compatible.\n *\n * @example\n * ```ts\n * import {\n *   decodeBase64Url,\n *   encodeBase64Url,\n * } from \"https://deno.land/std@$STD_VERSION/encoding/base64url.ts\";\n *\n * const binary = new TextEncoder().encode(\"foobar\");\n * const encoded = encodeBase64Url(binary);\n * console.log(encoded);\n * // => \"Zm9vYmFy\"\n *\n * console.log(decodeBase64Url(encoded));\n * // => Uint8Array(6) [ 102, 111, 111, 98, 97, 114 ]\n * ```\n *\n * @module\n */\n\nimport * as base64 from \"./base64.ts\";\n\n/*\n * Some variants allow or require omitting the padding '=' signs:\n * https://en.wikipedia.org/wiki/Base64#The_URL_applications\n * @param base64url\n */\nfunction addPaddingToBase64url(base64url: string): string {\n  if (base64url.length % 4 === 2) return base64url + \"==\";\n  if (base64url.length % 4 === 3) return base64url + \"=\";\n  if (base64url.length % 4 === 1) {\n    throw new TypeError(\"Illegal base64url string!\");\n  }\n  return base64url;\n}\n\nfunction convertBase64urlToBase64(b64url: string): string {\n  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {\n    // Contains characters not part of base64url spec.\n    throw new TypeError(\"Failed to decode base64url: invalid character\");\n  }\n  return addPaddingToBase64url(b64url).replace(/\\-/g, \"+\").replace(/_/g, \"/\");\n}\n\nfunction convertBase64ToBase64url(b64: string) {\n  return b64.endsWith(\"=\")\n    ? b64.endsWith(\"==\")\n      ? b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").slice(0, -2)\n      : b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").slice(0, -1)\n    : b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\n/**\n * @deprecated (will be removed in 0.210.0) Use a `encodeBase64Url` instead.\n *\n * Encodes a given ArrayBuffer or string into a base64url representation\n * @param data\n */\nexport const encode = encodeBase64Url;\n\n/**\n * @deprecated (will be removed in 0.210.0) Use a `decodeBase64Url` instead.\n *\n * Converts given base64url encoded data back to original\n * @param b64url\n */\nexport const decode = decodeBase64Url;\n\n/**\n * Encodes a given ArrayBuffer or string into a base64url representation\n * @param data\n */\nexport function encodeBase64Url(\n  data: ArrayBuffer | Uint8Array | string,\n): string {\n  return convertBase64ToBase64url(base64.encodeBase64(data));\n}\n\n/**\n * Converts given base64url encoded data back to original\n * @param b64url\n */\nexport function decodeBase64Url(b64url: string): Uint8Array {\n  return base64.decodeBase64(convertBase64urlToBase64(b64url));\n}\n", "import * as base64url from 'https://deno.land/std@0.204.0/encoding/base64url.ts';\nimport * as base64 from 'https://deno.land/std@0.204.0/encoding/base64.ts';\n\nexport type Header = {\n    alg: 'RS256';\n    [key: string]: unknown;\n};\n\nexport type Payload = {\n    iss: string;\n    aud: string;\n    exp: number;\n    iat: number;\n    scope: string;\n};\n\nconst encoder = new TextEncoder();\n\nexport default async function (\n    header: Header,\n    payload: Payload,\n    secret: string,\n): Promise<string> {\n    const encodedHeader = base64url.encode(JSON.stringify(header));\n    const encodedPayload = base64url.encode(JSON.stringify(payload));\n    const data = encoder.encode(`${encodedHeader}.${encodedPayload}`);\n\n    const cleanedKey = secret.replace(\n        /^\\n?-----BEGIN PRIVATE KEY-----\\n?|\\n?-----END PRIVATE KEY-----\\n?$/g,\n        '',\n    );\n    const decodedKey = base64.decode(cleanedKey).buffer;\n    const key = await crypto.subtle.importKey(\n        'pkcs8',\n        decodedKey,\n        { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },\n        true,\n        ['sign'],\n    );\n\n    const signature = await crypto.subtle.sign(\n        { hash: { name: 'SHA-256' }, name: 'RSASSA-PKCS1-v1_5' },\n        key,\n        data,\n    );\n    const encodedSignature = base64url.encode(signature);\n\n    return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;\n}\n"],
  "mappings": "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",
  "names": ["encoder"]
}
