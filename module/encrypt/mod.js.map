{
  "version": 3,
  "sources": ["../../encrypt/mod.ts"],
  "sourcesContent": ["const randomBytes = function (size: number) {\n    return crypto.getRandomValues(new Uint8Array(size)).buffer;\n};\n\nconst bufferToHex = function (data: ArrayBufferLike) {\n    return Array.from(new Uint8Array(data)).map((x) => x.toString(16).padStart(2, '0')).join('');\n};\n\nconst stringToBuffer = function (data: string) {\n    return new TextEncoder().encode(data);\n};\n\nexport default async function encrypt(\n    data: string,\n    secret: string,\n    options?: {\n        tag?: number;\n        length?: number;\n        iterations?: number;\n\n        hash?: string;\n        algorithm?: string;\n        seperator?: string;\n\n        salt?: number;\n        vector?: number;\n    },\n): Promise<string> {\n    if (!data) throw new Error(' data required');\n    if (!secret) throw new Error('secret required');\n\n    const tag = options?.tag || 128;\n    const length = options?.length || 256;\n    const hash = options?.hash || 'SHA-256';\n    const seperator = options?.seperator || '.';\n    const algorithm = options?.algorithm || 'AES-GCM';\n    const iterations = options?.iterations || 100_000;\n\n    const salt = typeof options?.salt === 'number' ? randomBytes(options.salt) : randomBytes(32);\n    const vector = typeof options?.vector === 'number' ? randomBytes(options.vector) : randomBytes(16);\n    const body = stringToBuffer(data);\n\n    const imported = await crypto.subtle.importKey(\n        'raw',\n        stringToBuffer(secret),\n        { name: 'PBKDF2' },\n        false,\n        ['deriveBits', 'deriveKey'],\n    );\n\n    const derived = await crypto.subtle.deriveKey(\n        { name: 'PBKDF2', salt, iterations, hash },\n        imported,\n        { name: algorithm, length },\n        true,\n        ['encrypt'],\n    );\n\n    const encrypted = await crypto.subtle.encrypt(\n        { iv: vector, name: algorithm, length, tagLength: tag },\n        derived,\n        body,\n    );\n\n    return [bufferToHex(encrypted), bufferToHex(salt), bufferToHex(vector)]\n        .join(seperator);\n}\n"],
  "mappings": ";;;;;;;;;;AAAA,IAAM,cAAc,SAAU,MAAc;AACxC,SAAO,OAAO,gBAAgB,IAAI,WAAW,IAAI,CAAC,EAAE;AACxD;AAEA,IAAM,cAAc,SAAU,MAAuB;AACjD,SAAO,MAAM,KAAK,IAAI,WAAW,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AAC/F;AAEA,IAAM,iBAAiB,SAAU,MAAc;AAC3C,SAAO,IAAI,YAAY,EAAE,OAAO,IAAI;AACxC;AAEA,eAAO,QACH,MACA,QACA,SAYe;AACf,MAAI,CAAC;AAAM,UAAM,IAAI,MAAM,gBAAgB;AAC3C,MAAI,CAAC;AAAQ,UAAM,IAAI,MAAM,iBAAiB;AAE9C,QAAM,MAAM,SAAS,OAAO;AAC5B,QAAM,SAAS,SAAS,UAAU;AAClC,QAAM,OAAO,SAAS,QAAQ;AAC9B,QAAM,YAAY,SAAS,aAAa;AACxC,QAAM,YAAY,SAAS,aAAa;AACxC,QAAM,aAAa,SAAS,cAAc;AAE1C,QAAM,OAAO,OAAO,SAAS,SAAS,WAAW,YAAY,QAAQ,IAAI,IAAI,YAAY,EAAE;AAC3F,QAAM,SAAS,OAAO,SAAS,WAAW,WAAW,YAAY,QAAQ,MAAM,IAAI,YAAY,EAAE;AACjG,QAAM,OAAO,eAAe,IAAI;AAEhC,QAAM,WAAW,MAAM,OAAO,OAAO;AAAA,IACjC;AAAA,IACA,eAAe,MAAM;AAAA,IACrB,EAAE,MAAM,SAAS;AAAA,IACjB;AAAA,IACA,CAAC,cAAc,WAAW;AAAA,EAC9B;AAEA,QAAM,UAAU,MAAM,OAAO,OAAO;AAAA,IAChC,EAAE,MAAM,UAAU,MAAM,YAAY,KAAK;AAAA,IACzC;AAAA,IACA,EAAE,MAAM,WAAW,OAAO;AAAA,IAC1B;AAAA,IACA,CAAC,SAAS;AAAA,EACd;AAEA,QAAM,YAAY,MAAM,OAAO,OAAO;AAAA,IAClC,EAAE,IAAI,QAAQ,MAAM,WAAW,QAAQ,WAAW,IAAI;AAAA,IACtD;AAAA,IACA;AAAA,EACJ;AAEA,SAAO,CAAC,YAAY,SAAS,GAAG,YAAY,IAAI,GAAG,YAAY,MAAM,CAAC,EACjE,KAAK,SAAS;AACvB;",
  "names": []
}
