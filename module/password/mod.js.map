{
  "version": 3,
  "sources": ["../../password/mod.ts"],
  "sourcesContent": ["/*\nhttps://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf\n\"5.1 The Salt (S)\" At least 16 bytes\n\"5.2 The Iteration Count (C)\" Minimum 1,000\n*/\n\ntype Options = {\n    length?: number;\n    hash?: string;\n    iterations?: number;\n    salt?: string | number | ArrayBuffer;\n    seperator?: string;\n};\n\nconst randomBytes = function (size: number): ArrayBuffer {\n    return crypto.getRandomValues(new Uint8Array(size)).buffer;\n};\n\nconst bufferToHex = function (data: ArrayBuffer): string {\n    return Array.from(\n        new Uint8Array(data),\n        (x) => x.toString(16).padStart(2, '0'),\n    ).join('');\n};\n\nconst stringToBuffer = function (data: string): ArrayBuffer {\n    return Uint8Array.from(data, (x) => x.charCodeAt(0)).buffer;\n};\n\nconst hexToBuffer = function (data: string): ArrayBuffer {\n    return Uint8Array.from(data.match(/.{2}/g) || [], (x) => parseInt(x, 16))\n        .buffer;\n};\n\nexport const PasswordCreate = async function (\n    secret: string,\n    options?: Options,\n): Promise<string> {\n    if (!secret) throw new Error('secret required');\n\n    const length = options?.length || 256;\n    const hash = options?.hash || 'SHA-256';\n    const seperator = options?.seperator || '.';\n    const iterations = options?.iterations || 100_000;\n\n    const salt = typeof options?.salt === 'string' ? stringToBuffer(options.salt) : typeof options?.salt === 'number' ? randomBytes(options.salt) : options?.salt instanceof ArrayBuffer ? options.salt : randomBytes(32);\n\n    const imported = await crypto.subtle.importKey(\n        'raw',\n        stringToBuffer(secret),\n        { name: 'PBKDF2' },\n        false,\n        ['deriveBits'],\n    );\n\n    const derived = await crypto.subtle.deriveBits(\n        { name: 'PBKDF2', hash, salt, iterations },\n        imported,\n        length,\n    );\n\n    return [bufferToHex(derived), bufferToHex(salt)].join(seperator);\n};\n\nexport const PasswordCompare = async function (\n    secret: string,\n    data: string,\n    options?: Options,\n): Promise<boolean> {\n    if (!data) throw new Error('data argument required');\n    if (!secret) throw new Error('password argument required');\n\n    const seperator = options?.seperator || '.';\n    const salt = await hexToBuffer(data.split(seperator)[1]);\n    const computed = await PasswordCreate(secret, { salt, ...options });\n\n    return data === computed;\n};\n\nexport default {\n    create: PasswordCreate,\n    compare: PasswordCompare,\n} as const;\n"],
  "mappings": ";;;;;;;;;;AAcA,IAAM,cAAc,SAAU,MAA2B;AACrD,SAAO,OAAO,gBAAgB,IAAI,WAAW,IAAI,CAAC,EAAE;AACxD;AAEA,IAAM,cAAc,SAAU,MAA2B;AACrD,SAAO,MAAM;AAAA,IACT,IAAI,WAAW,IAAI;AAAA,IACnB,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG;AAAA,EACzC,EAAE,KAAK,EAAE;AACb;AAEA,IAAM,iBAAiB,SAAU,MAA2B;AACxD,SAAO,WAAW,KAAK,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,EAAE;AACzD;AAEA,IAAM,cAAc,SAAU,MAA2B;AACrD,SAAO,WAAW,KAAK,KAAK,MAAM,OAAO,KAAK,CAAC,GAAG,CAAC,MAAM,SAAS,GAAG,EAAE,CAAC,EACnE;AACT;AAEO,IAAM,iBAAiB,eAC1B,QACA,SACe;AACf,MAAI,CAAC;AAAQ,UAAM,IAAI,MAAM,iBAAiB;AAE9C,QAAM,SAAS,SAAS,UAAU;AAClC,QAAM,OAAO,SAAS,QAAQ;AAC9B,QAAM,YAAY,SAAS,aAAa;AACxC,QAAM,aAAa,SAAS,cAAc;AAE1C,QAAM,OAAO,OAAO,SAAS,SAAS,WAAW,eAAe,QAAQ,IAAI,IAAI,OAAO,SAAS,SAAS,WAAW,YAAY,QAAQ,IAAI,IAAI,SAAS,gBAAgB,cAAc,QAAQ,OAAO,YAAY,EAAE;AAEpN,QAAM,WAAW,MAAM,OAAO,OAAO;AAAA,IACjC;AAAA,IACA,eAAe,MAAM;AAAA,IACrB,EAAE,MAAM,SAAS;AAAA,IACjB;AAAA,IACA,CAAC,YAAY;AAAA,EACjB;AAEA,QAAM,UAAU,MAAM,OAAO,OAAO;AAAA,IAChC,EAAE,MAAM,UAAU,MAAM,MAAM,WAAW;AAAA,IACzC;AAAA,IACA;AAAA,EACJ;AAEA,SAAO,CAAC,YAAY,OAAO,GAAG,YAAY,IAAI,CAAC,EAAE,KAAK,SAAS;AACnE;AAEO,IAAM,kBAAkB,eAC3B,QACA,MACA,SACgB;AAChB,MAAI,CAAC;AAAM,UAAM,IAAI,MAAM,wBAAwB;AACnD,MAAI,CAAC;AAAQ,UAAM,IAAI,MAAM,4BAA4B;AAEzD,QAAM,YAAY,SAAS,aAAa;AACxC,QAAM,OAAO,MAAM,YAAY,KAAK,MAAM,SAAS,EAAE,CAAC,CAAC;AACvD,QAAM,WAAW,MAAM,eAAe,QAAQ,EAAE,MAAM,GAAG,QAAQ,CAAC;AAElE,SAAO,SAAS;AACpB;AAEA,IAAO,cAAQ;AAAA,EACX,QAAQ;AAAA,EACR,SAAS;AACb;",
  "names": []
}
